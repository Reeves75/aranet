# Release workflow powered by cargo-dist
# This workflow builds and publishes release artifacts when a tag is pushed.
#
# To release:
#   1. Update version in Cargo.toml files
#   2. Commit: git commit -am "chore: release v0.1.0"
#   3. Tag: git tag v0.1.0
#   4. Push: git push origin main --tags
#
# cargo-dist will:
#   - Build binaries for all platforms
#   - Create GitHub Release with artifacts
#   - Generate shell/PowerShell install scripts
#   - Update Homebrew formula in tap repo

name: Release

permissions:
  contents: write

on:
  push:
    tags:
      - 'v[0-9]+.*'
  pull_request:
    paths:
      - '.github/workflows/release.yml'
      - 'Cargo.toml'
      - 'crates/*/Cargo.toml'

env:
  CARGO_TERM_COLOR: always

jobs:
  # Create the GitHub Release and upload global artifacts
  plan:
    runs-on: ubuntu-latest
    outputs:
      has-releases: ${{ steps.plan.outputs.has-releases }}
      releases: ${{ steps.plan.outputs.releases }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install cargo-dist
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Run cargo-dist plan
        id: plan
        run: |
          cargo dist plan --tag="${{ github.ref_name }}" --output-format=json > plan.json
          echo "has-releases=$(jq -r '.releases | length > 0' plan.json)" >> $GITHUB_OUTPUT
          echo "releases=$(jq -c '.releases' plan.json)" >> $GITHUB_OUTPUT
          cat plan.json

  # Build for each platform
  build:
    needs: plan
    if: needs.plan.outputs.has-releases == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: aarch64-apple-darwin
            os: macos-14
          - target: x86_64-apple-darwin
            os: macos-15-large
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-22.04
          - target: x86_64-pc-windows-msvc
            os: windows-2022
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libdbus-1-dev pkg-config

      - name: Install cross-compilation tools (Linux ARM64)
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
          echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: "1.90"
          targets: ${{ matrix.target }}

      - name: Install cargo-dist (Unix)
        if: runner.os != 'Windows'
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Install cargo-dist (Windows)
        if: runner.os == 'Windows'
        run: |
          irm https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.ps1 | iex

      - name: Build artifacts
        run: cargo dist build --tag="${{ github.ref_name }}" --target="${{ matrix.target }}"

      # Apple code signing and notarization for macOS
      - name: Import Apple certificate
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ]; then
            echo "APPLE_CERTIFICATE not set, skipping code signing"
            exit 0
          fi

          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"

          # Allow codesign to access the key
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "Certificate imported successfully"

      - name: Sign macOS binary
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ]; then
            echo "Skipping code signing (no certificate)"
            exit 0
          fi

          echo "Contents of target/distrib:"
          ls -la target/distrib/

          # Find the tarball (cargo-dist uses .tar.xz format)
          TARBALL=$(find target/distrib -name "aranet-cli-*.tar.xz" | head -1)
          if [ -z "$TARBALL" ]; then
            echo "No aranet-cli tarball found, checking for any tarball..."
            TARBALL=$(find target/distrib -name "*.tar.xz" | head -1)
          fi

          if [ -z "$TARBALL" ]; then
            echo "No tarball found in target/distrib"
            exit 1
          fi

          echo "Found tarball: $TARBALL"

          # Extract the tarball
          EXTRACT_DIR=$RUNNER_TEMP/extract
          mkdir -p "$EXTRACT_DIR"
          tar -xJf "$TARBALL" -C "$EXTRACT_DIR"

          echo "Extracted contents:"
          find "$EXTRACT_DIR" -type f

          # Find the binary
          BINARY_PATH=$(find "$EXTRACT_DIR" -name "aranet" -type f | head -1)
          if [ -z "$BINARY_PATH" ]; then
            echo "Binary 'aranet' not found in extracted tarball"
            exit 1
          fi

          echo "Signing binary at: $BINARY_PATH"

          # Sign with Developer ID Application certificate
          codesign --force --options runtime --sign "Developer ID Application: Cameron Rye ($APPLE_TEAM_ID)" \
            --timestamp "$BINARY_PATH"

          # Verify signature
          codesign -dv --verbose=4 "$BINARY_PATH"

          # Re-package the signed binary
          TARBALL_NAME=$(basename "$TARBALL")
          rm "$TARBALL"
          tar -cJf "target/distrib/$TARBALL_NAME" -C "$EXTRACT_DIR" .
          echo "Re-packaged signed binary into $TARBALL_NAME"

      - name: Notarize macOS binary
        if: runner.os == 'macOS' && startsWith(github.ref, 'refs/tags/')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ] || [ -z "$APP_STORE_CONNECT_KEY" ]; then
            echo "Skipping notarization (missing credentials)"
            exit 0
          fi

          # Find the tarball to notarize (cargo-dist uses .tar.xz)
          TARBALL=$(find target/distrib -name "aranet-cli-*.tar.xz" | head -1)
          if [ -z "$TARBALL" ]; then
            TARBALL=$(find target/distrib -name "*.tar.xz" | head -1)
          fi
          if [ -z "$TARBALL" ]; then
            echo "No tarball found to notarize"
            exit 0
          fi

          # Create a zip for notarization (Apple requires zip format)
          EXTRACT_DIR=$RUNNER_TEMP/notarize
          mkdir -p "$EXTRACT_DIR"
          tar -xJf "$TARBALL" -C "$EXTRACT_DIR"
          BINARY_PATH=$(find "$EXTRACT_DIR" -name "aranet" -type f | head -1)

          if [ -z "$BINARY_PATH" ]; then
            echo "Binary not found for notarization"
            exit 1
          fi

          ZIP_PATH=$RUNNER_TEMP/aranet-notarize.zip
          ditto -c -k --keepParent "$BINARY_PATH" "$ZIP_PATH"

          # Write the API key to a file
          mkdir -p $RUNNER_TEMP/private_keys
          echo "$APP_STORE_CONNECT_KEY" > $RUNNER_TEMP/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8

          echo "Submitting for notarization..."
          xcrun notarytool submit "$ZIP_PATH" \
            --key "$RUNNER_TEMP/private_keys/AuthKey_${APP_STORE_CONNECT_KEY_ID}.p8" \
            --key-id "$APP_STORE_CONNECT_KEY_ID" \
            --issuer "$APP_STORE_CONNECT_ISSUER_ID" \
            --wait

          echo "Notarization complete"

      - name: Clean up keychain
        if: runner.os == 'macOS' && always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.target }}
          path: target/distrib/

  # Publish the release
  publish:
    needs: [plan, build]
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: target/distrib/
          merge-multiple: true

      - name: Install cargo-dist
        run: |
          curl --proto '=https' --tlsv1.2 -LsSf https://github.com/axodotdev/cargo-dist/releases/latest/download/cargo-dist-installer.sh | sh

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cargo dist plan --tag="${{ github.ref_name }}" --output-format=json > plan.json

          # Create release notes from CHANGELOG if available
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"

          # List only top-level files in target/distrib (not files inside subdirectories)
          # These are the actual release artifacts (.tar.xz, .sha256, installer scripts, etc.)
          echo "Files to upload:"
          find target/distrib -maxdepth 1 -type f | head -20

          # Create the release with only top-level files (not extracted contents in subdirectories)
          gh release create "${{ github.ref_name }}" \
            --title "Aranet CLI ${{ github.ref_name }}" \
            --generate-notes \
            $(find target/distrib -maxdepth 1 -type f)

      - name: Update Homebrew tap
        if: success()
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          if [ -n "$HOMEBREW_TAP_TOKEN" ]; then
            cargo dist plan --tag="${{ github.ref_name }}" --artifacts=global --output-format=json > plan.json
            echo "Homebrew formula would be updated here"
            # The actual update happens via cargo-dist's homebrew installer
          else
            echo "HOMEBREW_TAP_TOKEN not set, skipping Homebrew tap update"
          fi

